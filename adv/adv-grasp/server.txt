import Pyro4
import os
import logging
import numpy as np
import json
from pysdfgen import mesh2sdf
from meshpy.obj_file import ObjFile
from meshpy.sdf_file import SdfFile
from meshpy import mesh 
from dexnet.grasping import GraspableObject3D, RobotGripper, UniformGraspSampler, GraspQualityConfigFactory, GraspQualityFunctionFactory, ParallelJawPtGrasp3D
from autolab_core import YamlConfig, Point
from perception import DepthImage, CameraIntrinsics, ColorImage, RgbdImage
from gqcnn.grasping import AntipodalDepthImageGraspSampler, GQCnnQualityFunction, Grasp2D
from gqcnn.grasping.policy import RgbdImageState

Pyro4.config.COMMTIMEOUT = None

CONFIG = YamlConfig('dex_shared_dir/config.yaml')
ROBUST_CONFIG = YamlConfig('dex_shared_dir/config_robust.yaml')
# GRASP_CONFIG = YamlConfig('/deps/gqcnn/cfg/examples/antipodal_grasp_sampling.yaml')
# GQCNN_CONFIG = YamlConfig('/deps/gqcnn/cfg/examples/replication/dex-net_2.1.yaml')
SHARED_DIR = "dex_shared_dir"


@Pyro4.expose
class Server(object):

	def add(self, a, b):
		"""add function just for testing"""
		return a + b

	def quality(self, grasp, obj, robust=True):
		"""returns ferrari canny quality, robust_quasi_static by default, quasi_static otherwise"""

		if robust:
			quality_config = GraspQualityConfigFactory.create_config(ROBUST_CONFIG['metrics']['robust_ferrari_canny'])
		else:
			quality_config = GraspQualityConfigFactory.create_config(CONFIG['metrics']['robust_ferrari_canny'])

		quality_fn = GraspQualityFunctionFactory.create_quality_function(obj, quality_config)
		return quality_fn(grasp).quality

	def close_fingers(self, centerfile, axisfile, min_qual, max_qual, objfile="bar_clamp.obj"):

		# list to store return values
		ret = []
	
		# create GraspableObject3D
		obj_path = os.path.join(SHARED_DIR, objfile)
		of = ObjFile(obj_path)
		mesh = of.read()
		sdf_file = objfile.split(".")[0] + ".sdf"
		sdf_path = os.path.join(SHARED_DIR, sdf_file)
		if not os.path.isfile(sdf_path):
			mesh2sdf(obj_path)
		sf = SdfFile(sdf_path)
		sdf = sf.read()
		obj = GraspableObject3D(sdf, mesh)
		# print "center of mass: ", obj.mesh.center_of_mass

		# confirmed meshpy mesh has same world coordinates as pytorch mesh
		# print(mesh.principal_dims())
		# print(mesh.bb_center)

		# create ParallelJawPtGrasp3D object from grasp list
		centers = np.load(os.path.join(SHARED_DIR, centerfile))
		axes = np.load(os.path.join(SHARED_DIR, axisfile))	
		logger.info("%d grasps to check", centers.shape[0])
		for i in range(centers.shape[0]):
			if i % 100 == 0:
				logger.info("checking grasp %d/%d", i, centers.shape[0])
			center = centers[i]
			axis = axes[i]
			g = ParallelJawPtGrasp3D(ParallelJawPtGrasp3D.configuration_from_params(center, axis, 0.05))
			success, contacts = g.close_fingers(obj)
			q = 0.0

			if success:
				q = self.quality(g, obj)
				if q >= min_qual and q <= max_qual:
					contact_arrs = (contacts[0].point.tolist(), contacts[1].point.tolist())
					ret.append([i, success, q, contact_arrs])
					logger.info("SUCCESS - contact points: %s, %s\tquality: %s", contacts[0].point, contacts[1].point, q)
					# data = {"pytorch_w_axis": axis.tolist(), "pytorch_w_center": center.tolist(), "dex_w_axis": g.axis.tolist(), "dex_w_center": g.center.tolist(), "contact_points": [contact_arrs[0], contact_arrs[1]], "rfc_quality": q}
					# userfile = raw_input("Creating new file for data collection, please provide name: /deps/dex/src/dexnet/grasping/")
					# userfile = "src/dexnet/grasping/" + userfile
					# with open(userfile, 'w') as file1:
					#	json.dump(data, file1, indent=4)
					# print "created file, re-collecting data..."
					print "-----------------------------------------"
					print "-----------------------------------------"

		return ret 

	def final_evals(self, centerfile, axisfile, objfile, robust=True):

		ret = []

		# create GraspableObject3D
		obj_path = os.path.join(SHARED_DIR, objfile)
		of = ObjFile(obj_path)
		mesh = of.read()
		sdf_file = objfile.split(".")[0] + ".sdf"
		sdf_path = os.path.join(SHARED_DIR, sdf_file)
		if not os.path.isfile(sdf_path):
				mesh2sdf(obj_path)
		sf = SdfFile(sdf_path)
		sdf = sf.read()
		obj_path = os.path.join(SHARED_DIR, objfile)
		of = ObjFile(obj_path)
		mesh = of.read()
		sdf_file = objfile.split(".")[0] + ".sdf"
		sdf_path = os.path.join(SHARED_DIR, sdf_file)
		if not os.path.isfile(sdf_path):
				mesh2sdf(obj_path)
		sf = SdfFile(sdf_path)
		sdf = sf.read()
		obj = GraspableObject3D(sdf, mesh)

		# create ParallelJawPtGrasp3D object from grasp list
		centers = np.load(os.path.join(SHARED_DIR, centerfile))
		axes = np.load(os.path.join(SHARED_DIR, axisfile))
		logger.info("%d grasps for final eval", centers.shape[0])
		for i in range(centers.shape[0]):
			center = centers[i]
			axis = axes[i]
			g = ParallelJawPtGrasp3D(ParallelJawPtGrasp3D.configuration_from_params(center, axis, 0.05))
			success, contacts = g.close_fingers(obj)
			q = 0.0

			if success:
				q = self.quality(g, obj, robust=robust)

			ret.append(q)

		return ret

# set up logger
logger = logging.getLogger("dexnet_server")
logger.setLevel(logging.DEBUG)
# ch = logging.StreamHandler()
# ch.setLevel(logging.DEBUG)
# formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# ch.setFormatter(formatter)
# logger.addHandler(ch)

logger.info("info message 1")

daemon = Pyro4.Daemon(host='0.0.0.0', port=5000)
uri = daemon.register(Server, "Server")

print "Ready. Object uri = ", uri
daemon.requestLoop()

